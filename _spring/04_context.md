---
layout: page
title: "Контекст, профили и конфигурационные свойства"
permalink: /spring/context
---

# Контекст, профили и конфигурационные свойства

## Плавный вход: ApplicationContext и Environment

ApplicationContext — это «мозг» приложения Spring: регистрирует определения бинов, создаёт экземпляры, связывает зависимости, управляет жизненным циклом и событиями. Он знает о профилях, источниках настроек, ресурсах, сообщениях (MessageSource) и публикует события жизненного цикла. Для нас важно, что именно контекст решает, **какие** бины появятся (через профили/условия) и **с какими значениями** они будут инициализированы (через свойства).

Environment — это «снимок» внешней конфигурации и активных профилей: набор `PropertySource` (системные свойства, переменные окружения, файлы `application.yml`/`application.properties`, и т. д.) + флаги профилей (`active`, `default`). Контекст использует Environment на ранних этапах, чтобы принять конфигурационные решения: какие `@Configuration`/`@Bean` активировать, какие значения проставить в `@Value`/`@ConfigurationProperties`.

Ключевая идея Spring Boot — **externalized configuration**: настройки находятся снаружи кода и подмешиваются в рантайме. Это позволяет менять поведение приложения (порты, БД, логирование, фичи-флаги) без перекомпиляции. Источники упорядочены по приоритетам: чем «ближе» к запуску (CLI-параметры, `-D`, ENV), тем выше приоритет над файлами в classpath.

Важное следствие: любой модуль/бин не должен сам «искать» файлы и парсить конфиги — он **декларирует** поля/свойства, а контейнер биндингом и приоритетами подтянет финальные значения из Environment. Это даёт тестируемость (легко переопределять), повторяемость и предсказуемость.

---

## Externalized configuration: способы чтения и когда чем пользоваться

Частые способы чтения свойств три: `@ConfigurationProperties`, `@Value` и явный доступ к `Environment`. Последний нужен редко — для инфраструктурного кода, где нет смысла плодить бин-конфиги. В прикладном коде почти всегда уместны типобезопасные бин-классы или, в крайнем случае, точечные `@Value`.

`@ConfigurationProperties` связывает дерево настроек с Java-классом: есть префикс, поля (включая вложенные), коллекции/карты, валидация и конвертация типов. Это предпочтительный путь для «наборов настроек», потому что он документируемый, тестируемый и расширяемый без рефакторинга вызывающего кода.

`@Value` инжектит одно значение (или простую SpEL-выражение) в поле/конструктор: быстро, но хрупко для больших наборов свойств. Минусы — строковые ключи размазаны по коду, слабая типобезопасность, повторяемость, сложнее валидировать консистентность (например, два поля должны соответствовать друг другу по правилу).

`Environment` читают так: `env.getProperty("app.timeout-ms", Integer.class, 2000)`. Плюс — гибкость; минус — вы вручную решаете типы/дефолты, легко ошибиться и потерять видимость настроек. Оставляйте это в инфраструктуре (например, «мост» к сторонней библиотеке, которая сама не умеет биндинг).

---

## @ConfigurationProperties vs @Value, relaxed binding и валидация

Когда выбирать `@ConfigurationProperties`, а не `@Value`? Всегда, когда у вас **группа связанных** опций: параметры HTTP-клиента, БД, кэша, интеграционного клиента. Это даёт вам типобезопасность, вложенность, коллекции, карты, дефолты и JSR-380-валидацию «в одном месте».

```yaml
app:
  http:
    base-url: https://api.example.com
    timeout-ms: 2500
    headers:
      User-Agent: Demo
      X-Feature: true
```

```java
@ConfigurationProperties(prefix = "app.http")
@Validated
public class HttpProps {
    @NotNull private URI baseUrl;
    @Min(0) private int timeoutMs = 2000;
    private Map<String, String> headers = new HashMap<>();
    // getters/setters
}

@Configuration
@EnableConfigurationProperties(HttpProps.class)
class HttpConfig {
    @Bean
    RestClient restClient(HttpProps p) {
        return RestClient.builder()
                .baseUrl(p.getBaseUrl().toString())
                .requestFactory(factory -> factory.setReadTimeout(Duration.ofMillis(p.getTimeoutMs())))
                .defaultHeaders(h -> p.getHeaders().forEach(h::add))
                .build();
    }
}
```

**Relaxed binding** — «гибкое» сопоставление имён: `base-url`, `base_url`, `BASE_URL`, `baseUrl` — всё это свяжется с `baseUrl`. То же справедливо для ENV-переменных: `APP_HTTP_BASE_URL` → `app.http.base-url`. Благодаря relaxed binding удобно переключаться между YAML, JVM-параметрами и ENV без боли в кейсинге и разделителях.

`@Value` оставляйте для единичных значений или тривиальных флагов, особенно внутри конфигураций сторонних бинов. Но не стройте из `@Value` «квазиконфигурации» — вы потеряете обозримость. И да: не злоупотребляйте SpEL в `@Value` — это усложняет понимание и может неожиданно «стрельнуть» на старте.

---

## Профили: активация, include, группы и приоритетность конфигов

Профили включают/исключают бины и конфиги под конкретные среды: `dev`, `test`, `prod`, `local`, `ci`. Активировать можно тремя способами: через `spring.profiles.active` (ENV или `-D`), через CLI `--spring.profiles.active=dev`, или программно в `SpringApplicationBuilder`. Профили влияют на условные аннотации (`@Profile`, `@ConditionalOnExpression`/`OnProperty`) и на выбор секций конфигов.

`spring.profiles.include` — «добавь к активным вот эти»: удобно объявить общий `common` и включать его в `dev`/`prod`, не повторяя блоки. Но помните: include не «перезаписывает» active — он **расширяет** набор.

Группы профилей `spring.profiles.group.<name>=a,b,c` дают псевдонимы: активируете `name`, а реально включаются `a`, `b`, `c`. Это полезно для сложных сред: `blue` может означать `prod,datacenter2,featureX`.

Файлы `application-<profile>.yml` подмешиваются поверх базового `application.yml` по приоритету активных профилей (последний активированный имеет больший приоритет среди равных источников). Если профиль несколько, порядок важен: «поздний» перебивает «раннего». Для сложных случаев лучше явно управлять порядком активных профилей.

---

## Multi-document YAML и `spring.config.activate.on-profile`

YAML в Spring Boot поддерживает несколько документов в одном файле, разделённых `---`. Это позволяет держать настройки для разных профилей или сценариев в одном физическом файле, не плодя много маленьких. Условная активация секции достигается через `spring.config.activate.on-profile`.

```yaml
# application.yml
server:
  port: 8080

---
spring:
  config:
    activate:
      on-profile: dev
logging:
  level:
    root: DEBUG

---
spring:
  config:
    activate:
      on-profile: prod
server:
  port: 8081
```

Multi-document полезен, когда у вас мало отличий между профилями и удобно держать всё рядом. Но если конфиг разрастается — лучше разделить по файлам профильных конфигов, чтобы не устраивать «простыню».

Слияние коллекций здесь важно понимать: **списки** по умолчанию **заменяются целиком**, а не дополняются. То есть если в базовом документе `list: [a,b]`, а в профильном `list: [c]`, итог — `[c]`. Поэтому рассчитывать на «частичное» расширение списков нельзя — либо дублируйте всё значение, либо используйте карты, где ключи можно дозаполнять.

---

## Маппинг ENV → свойства и «правила склеивания»

ENV-переменные маппятся по relaxed binding: `SERVER_PORT=9090` станет `server.port`. Точки заменяются на подчеркивания, регистр игнорируется, дефисы допускаются. Для вложенности используйте двойное подчеркивание, если shell «съедает» одинарное (в Docker Compose это не требуется, но в некоторых CI пригодится).

Стоит помнить о типах: всё в ENV — строки, а биндинг обязан сконвертировать. Для URI/Duration/Enums/Sets конвертация есть «из коробки», но внимательно относитесь к форматам (например, `Duration` — `10s`, `500ms`).

При одновременном наличии значения в ENV и в YAML побеждает источник с **большим приоритетом** (обычно ENV). Если вы хотите «заморозить» значение в профиле и запретить переопределение — это анти-паттерн; правильнее контролировать, **где** разрешены изменения, а не «сломом» механизма приоритетов.

---

## Подключение дополнительных мест для конфигов и `spring.config.import`

Spring Boot позволяет расширять места поиска конфигов через `spring.config.additional-location` или полностью **заменять** стандартную схему через `spring.config.location` (важно: несколько путей разделяйте `;`). Это удобно для разделения «бинарника» и «сетапа» на машине/контейнере.

```bash
java -jar app.jar \
  --spring.config.additional-location=file:/etc/myapp/,optional:file:/opt/secure/
```

`spring.config.import` — механизм **импорта** конфигов из других источников: файлы/папки, `configtree:` (дерево файлов, где имя — ключ, содержимое — значение, удобно для секретов в Docker/K8s), а также внешние системы (через Spring Cloud). Пример с configtree:

```yaml
spring:
  config:
    import: "optional:configtree:/run/secrets/"
app:
  db:
    username: ${db_username}   # файл /run/secrets/db_username
    password: ${db_password}   # файл /run/secrets/db_password
```

YAML через `@PropertySource` подключать нельзя — эта аннотация понимает `.properties`. Если очень надо YAML как `@PropertySource`, нужен кастомный `PropertySourceFactory` (инфраструктурный код). В Boot-проектах вместо `@PropertySource` почти всегда лучше использовать штатную схему поиска/импорта.

---

## Валидация конфигурации и диагностика

`@ConfigurationProperties` поддерживает валидацию через `@Validated` и аннотации JSR-380. Это даёт раннюю остановку старта при некорректных значениях. Валидируйте не только «минимумы/максимумы», но и **инварианты**: например, если включён TLS — проверьте, что заданы путь к truststore/пароль.

Чтобы посмотреть все забинденные `@ConfigurationProperties`, включите Actuator и откройте эндпоинт `configprops` (доступ ограничьте). Это удобный способ увидеть финальные значения и источник (без секретов), понять, что «победило» при конфликте.

Для отладки биндинга включайте `debug=true` или установленный уровень логгера `org.springframework.boot.context.properties` в `TRACE/DEBUG`. Также полезно вывести список `PropertySources` и их порядок — это часто сразу объясняет «почему не берётся мой порт».

Секреты храните вне репозитория кода: ENV/K8s Secret/`configtree`/секрет-менеджеры (Vault, AWS/GCP/Azure). Никогда не коммитите пароли в `application.yml`. Для локалки используйте `application-local.yml` (в `.gitignore`) и активируйте профиль `local`.

---

## Профили: тонкости, приоритеты и «самоактивация»

Если указать `spring.profiles.active` **внутри профильного документа** (в секции, активирующейся этим же профилем), получится «курица и яйцо». Правильно задавать активный профиль **снаружи**: через ENV, `-D`, CLI, `SPRING_PROFILES_ACTIVE` в Docker/K8s. Внутри документов используйте `spring.config.activate.on-profile`.

Слияние карт (map) — по ключам: профиль может добавлять/переопределять отдельные ключи. Списки — заменяются целиком. Поэтому «частично расширить список» профилем нельзя — всегда указывайте весь список. Это особенно важно для `spring.main.sources`, `allowed-origins` и т. п.

Группы профилей (`spring.profiles.group.*`) удобны для многофакторных окружений. Например, `blue` может включать `prod` + `dc2` + `featureX`. Активируете `blue`, а приложение получает тройной набор. Это проще, чем помнить «что именно включать» руками.

`spring.profiles.include` полезен для инкрементальной сборки профилей («dev» включает «common»), но не используйте include для попыток «переопределить порядок» — порядок управляется активными профилями и локациями конфигов.

---

## Docker/K8s: как передавать profile и конфиги

В Docker самый простой способ — ENV:

```yaml
# docker-compose.yml
services:
  app:
    image: myapp:latest
    environment:
      SPRING_PROFILES_ACTIVE: dev
      SERVER_PORT: 8080
    volumes:
      - ./config/:/config/           # стандартная точка поиска в Boot
```

Boot ищет конфиги и в `/config` внутри контейнера; это удобный способ подложить `application.yml` без пересборки образа. Для секретов используйте Docker secrets + `configtree` (`/run/secrets`).

В Kubernetes передавайте профили и значения через ConfigMap/Secret как переменные окружения или примонтированные файлы; для биндинга деревьев — `configMap`/`secret` как volume и `spring.config.import=configtree:/etc/app-config/`. Профили — `SPRING_PROFILES_ACTIVE` в spec.env.

Группировка локаций через `;` в `spring.config.location` позволяет точно контролировать порядок. Это уместно в CI, где вы хотите жёстко определить список файлов/папок, исключив дефолтные пути.

---

## Программная активация профилей и модульная конфигурация

Иногда профили удобнее задавать программно: интеграционные тесты, embedded-запуск, launchers. Тогда используйте `SpringApplicationBuilder` или инициализаторы:

```java
new SpringApplicationBuilder(App.class)
    .profiles("testdata", "ci")
    .run(args);
```

Или `ApplicationContextInitializer<ConfigurableApplicationContext>` для вычисления профиля по внешнему сигналу (например, переменная окружения с именем датацентра). Но не злоупотребляйте: программная активация сложнее для сопровождения, чем декларативная через ENV/CLI.

Модульная конфигурация для больших проектов — набор «тонких» конфигураций по доменам (WebConfig, DataConfig, MessagingConfig, ObservabilityConfig) и импорты: `@Import({DataConfig.class, WebConfig.class})`. Для библиотек — стартеры (auto-configuration) с условной регистрацией и `@ConfigurationProperties`.

---

## Практические примеры: профильные бины и условия

Активируйте бины на профили через `@Profile`:

```java
@Configuration
@Profile("dev")
class DevDataConfig {
    @Bean(initMethod = "start", destroyMethod = "stop")
    EmbeddedPostgres embeddedPg() { return EmbeddedPostgres.builder().setPort(5544).start(); }
}

@Configuration
@Profile("prod")
class ProdDataConfig {
    @Bean
    DataSource dataSource(AppDbProps p) { return new HikariDataSource(p.hikari()); }
}
```

Условная регистрация через Boot-аннотации:

```java
@Configuration
class MetricsAutoConfig {
    @Bean
    @ConditionalOnClass(io.micrometer.core.instrument.MeterRegistry.class)
    @ConditionalOnProperty(prefix = "metrics", name = "enabled", havingValue = "true", matchIfMissing = true)
    MeterRegistry meterRegistry() { return new SimpleMeterRegistry(); }
}
```

Чётко отделяйте «что включать» (профили/условия) от «какие значения туда подставить» (ConfigurationProperties). Это снижает связность и делает поведение приложения прозрачно управляемым.

---

## Где хранить секреты и почему `@PropertySource` редко нужен в Boot

Секреты — только вне VCS: ENV/K8s Secret/`configtree:/run/secrets`/внешние секрет-менеджеры. Для локалки — `.env`/`application-local.yml` в `.gitignore`. Никогда не оставляйте дефолтные пароли в `application.yml`, даже для dev — кто-то забудет их сменить.

`@PropertySource` полезен в Boot-проектах лишь для специфических `.properties`, которые лежат **в нестандартном месте** и должны подмешаться **раньше** биндинга. Для YAML — не подходит (если только с кастомным `PropertySourceFactory`). В 99% случаев используйте стандартные локации/импорт.

`spring.config.import` закрывает большинство сценариев, где раньше писали `@PropertySource`: можно импортировать файл/папку/дерево секретов и управлять optional-семантикой без кода.

---

## Подводные камни: `@Value`, списки, «частичные правки», порядок источников

Опасности `@Value`:
— Размазывание ключей по коду: трудно найти все места использования.
— Отсутствие валидации на набор: одно поле провалидируете, но инварианты между полями — нет.
— Сложные SpEL-выражения скрывают логику, а ошибки всплывают на старте в неожиданных местах.
— Не работает сквозная переинициализация, если вы когда-то захотите «горячий» ребайнд (в продакшене такое редко и не нужно).

Списки не «расширяются» профилями — только заменяются. Это частая ловушка: в `dev` «потеряли» элементы из базовой секции. Решение — указывать весь список явно или моделировать как `Map` и дозаполнять ключи.

Нельзя рассчитывать на «частичное» изменение свойства в профиле, если это «атомарное» значение (строка/число). Например, нельзя подменить «кусок» URL — только целиком. Декомпозируйте на части (`host`, `port`, `path`) или вычисляйте итог в коде.

Порядок источников важен. Если вы добавляете дополнительную локацию конфигов и ждёте, что она «перебьёт» ENV — не перебьёт: ENV выше. И наоборот: если конфиг из файла «не берётся», проверьте, не перекрыт ли он `-D`/ENV/CLI.

---

## Быстрые рецепты: профили и конфиги из консоли и CI

Запуск с профилем и портом:

```bash
java -jar app.jar --spring.profiles.active=dev --server.port=8082
```

Через JVM-параметры:

```bash
java -Dspring.profiles.active=prod -Dserver.port=8080 -jar app.jar
```

Через ENV (CI/Docker/K8s):

```bash
export SPRING_PROFILES_ACTIVE=ci
export SERVER_PORT=8085
java -jar app.jar
```

Дополнительная локация и импорт:

```bash
java -jar app.jar \
  --spring.config.additional-location=file:/etc/myapp/ \
  --spring.config.import=optional:configtree:/run/secrets/
```

Программно (launcher для тестов):

```java
SpringApplication app = new SpringApplication(App.class);
app.setAdditionalProfiles("it");
app.run(args);
```

---

## Итог

Контекст (ApplicationContext) управляет жизнью приложения, Environment — его внешними «настройками и профилями». В Spring Boot конфигурация вынесена наружу и подчиняется чёткой иерархии источников. **Выбор инструмента важен**: `@ConfigurationProperties` — для наборов опций (типобезопасность, вложенность, валидация); `@Value` — для единичных, простых значений; `Environment` — для инфраструктурных мостов.

Профили — механизм формирования «состава» бинов и секций конфигов, include/группы — для композиции окружений, multi-document и `on-profile` — для удобной организации YAML. ENV-переменные маппятся по relaxed binding; списки заменяются целиком; карты сливаются по ключам. Дополнительные локации и `spring.config.import` закрывают распространённые сценарии доставки конфигов и секретов в Docker/K8s без изменения образа.

Практика: активируйте профили извне, группируйте конфиги модульно, валидируйте `@ConfigurationProperties`, храните секреты вне VCS, не злоупотребляйте `@Value`, не рассчитывайте на «частичное» расширение списков и всегда помните про порядок источников. С таким фундаментом следующая тема — «Spring Boot под капотом: авто-конфигурация и стартеры» — ляжет на понятную основу: вы уже контролируете, **что** попадает в контекст и **с какими** значениями.
