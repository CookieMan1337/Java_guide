---
layout: page
title: "Spring Data JPA: Основы"
permalink: /spring/mvc
---

### Getting Started

Начинать проще всего с добавления стартеров. Для Gradle (Kotlin DSL) достаточно `spring-boot-starter-data-jpa` и драйвера вашей БД. В учебных целях можно добавить `spring-boot-starter-web`, чтобы сразу вызвать репозитории из контроллера и увидеть результат в браузере или через curl. В боевых условиях список зависимостей дополняют средства миграций (Flyway/Liquibase) и тестовые библиотеки (Testcontainers, H2/Embedded-Postgres).

Далее — минимальная конфигурация в `application.yml`: URL БД, логин/пароль, диалект Hibernate. В прототипах иногда применяют `spring.jpa.hibernate.ddl-auto=update`, чтобы Hibernate сам создавал/обновлял схему, но в продакшене схему управляют только миграциями. Полезно включить логирование SQL (`spring.jpa.show-sql=true`) и параметров (`hibernate.format_sql=true` + логгер JDBC), чтобы понимать, что реально уходит в БД.

Создайте простую сущность и репозиторий. Это уже даст CRUD: `save`, `findById`, `findAll`, `deleteById`, а также пагинацию и сортировку «из коробки». Начинайте с элементарного потока «контроллер → сервис → репозиторий»: так быстрее получить обратную связь, увидеть, как работает ленивость загрузки и где возникают ошибки N+1.

Важно помнить: Spring Data JPA — надстройка над JPA/Hibernate. Это не «замена SQL», а способ думать объектами и делегировать низкоуровневую рутину ORM-слою. Чем лучше вы понимаете правила JPA (контекст постоянства, состояния сущностей, flush), тем предсказуемее работает ваш код.

### Быстрый старт: зависимости, сущность, репозиторий, первый запуск

Сначала зависимости (Gradle Kotlin DSL):

```groovy
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    runtimeOnly 'org.postgresql:postgresql'
}
```

Создадим простую сущность:

```java
@Entity
@Table(name = "books")
public class Book {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "book_seq")
    @SequenceGenerator(name = "book_seq", sequenceName = "book_seq", allocationSize = 50)
    private Long id;

    private String title;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "author_id") // владелец связи
    private Author author;

    // getters/setters
}
```

И репозиторий:

```java
public interface BookRepository extends JpaRepository<Book, Long> {
    List<Book> findByTitleContainingIgnoreCase(String part, Sort sort);
}
```

Всё: при старте Boot создаст `EntityManagerFactory`, откроет DataSource, поднимет контекст. Вы можете инжектить `BookRepository` и вызывать `.save`, `.findById`, `.findAll(Pageable)`, методы по имени и т.д. Для локальной работы удобно добавить `spring.jpa.hibernate.ddl-auto=update` (только для прототипов) и настроить `spring.jpa.show-sql=true` для понимания, что реально выполняется в БД.



### Core Concepts

Сердце JPA — `EntityManager` и контекст постоянства (Persistence Context). Внутри активной транзакции все загруженные сущности находятся под управлением контекста, то есть `managed`: ORM отслеживает изменения их полей. Благодаря этому **dirty checking** при `flush` переводит изменённые свойства в `UPDATE`-запросы автоматически — без явного вызова `update`.

Существуют четыре состояния сущности: **transient** (только что созданный объект, БД его не знает), **managed** (под контролем контекста), **detached** (объект живёт вне контекста — например, после завершения транзакции) и **removed** (помечен к удалению). Характерные ошибки новичков часто происходят при попытке менять `detached`-объект и ожидать, что изменения «сами» сохранятся.

Контекст обеспечивает **dirty checking**: вы изменили поле managed-сущности — и при `flush` JPA сгенерирует `UPDATE` автоматически, без ручного SQL. Это удобство и потенциальный источник «невидимых» обновлений, если не понимать, когда происходит `flush`.

`flush` — это синхронизация контекста с базой. Он срабатывает автоматически:

1. перед выполнением JPQL/Criteria-запроса, который может зависеть от несинхронизированных изменений;
2. при коммите транзакции;
3. по вашему вызову `entityManager.flush()`;
4. иногда — из-за настроек FlushMode.

Понимание моментов `flush` важно для производительности (лишних синхронизаций лучше избегать) и корректности (например, зависимые запросы должны видеть уже применённые изменения).


Persistence Context — это также первый уровень кеширования. Повторная загрузка той же сущности по тому же `id` в рамках транзакции не отправит второй `SELECT`. Но этот кеш сугубо внутритранзакционный: между разными транзакциями он не работает. Второй уровень кеша — отдельная, продвинутая тема и включается осознанно.


### Defining Repository Interfaces

Spring Data JPA предлагает декларативные репозитории. Интерфейса `JpaRepository<T, ID>` достаточно, чтобы получить полный набор CRUD-операций, пагинацию (`Pageable`), сортировку (`Sort`) и множество полезных расширений. Реализации генерируются автоматически, а вы концентрируетесь на доменной модели и запросах.

Возвращаемые типы методов гибки: одиночные выборки — через `Optional<T>`, коллекции — `List<T>`, страничные — `Page<T>` или более лёгкий `Slice<T>`. Есть также стримовые результаты (`Stream<T>`), которые важно использовать в транзакции и закрывать. Чем точнее вы выбираете возвращаемый тип, тем легче потребителям API обрабатывать сценарий «не найдено».

Сильная сторона Spring Data — **derived queries**, то есть методы, где имя кодирует условие: `findByTitleContainingIgnoreCase`, `findTopByAuthorIdOrderByIdDesc`, `existsByIsbn`, `countByAuthor_Name`. Это читаемо и покрывает большинство стандартных фильтров без ручного JPQL. Когда имя становится чрезмерно длинным — это сигнал перейти на явный `@Query` или Specification.

Для более сложных сценариев интерфейс можно расширить `JpaSpecificationExecutor<T>` (динамические фильтры), добавить кастомный фрагмент с ручным `EntityManager`, а также объявлять методы модификации (`@Modifying`) и графы загрузки (`@EntityGraph`). Все эти механизмы отлично комбинируются под одну предметную область.


### Configuration

В Spring Boot большая часть JPA-конфигурации — автоконфиг. Достаточно указать DataSource и зависимость JPA, а `LocalContainerEntityManagerFactoryBean` и `PlatformTransactionManager` создадутся автоматически. Сканирование сущностей идёт по пакетам, где лежит класс `@SpringBootApplication`. Если сущности в других модулях — проверьте, что пакеты доступны сканеру.

Настроечные свойства Hibernate влияют на поведение и производительность. Часто используемые: `hibernate.jdbc.batch_size` (батч-размер для вставок/обновлений), `hibernate.order_inserts/updates` (группировка), `hibernate.format_sql` (читабельный SQL), `hibernate.default_batch_fetch_size` (батч-подгрузка ленивых связей). Для PostgreSQL используйте современный диалект (`org.hibernate.dialect.PostgreSQLDialect`) — он выбирается автоматически в свежих версиях.

Режим `ddl-auto` следует отключать в продакшене. Управление схемой — зона ответственности Flyway/Liquibase, что обеспечивает повторяемость и контроль миграций. На тестах удобно применять Testcontainers, чтобы интеграционные тесты шли против реального Postgres, а не против in-memory БД с другим диалектом.

Наконец, заранее спланируйте стратегию логирования. Включайте SQL и параметры хотя бы на тестах, а для продакшена — логируйте медленные запросы и собирайте метрики (например, через Micrometer + наблюдаемость). Это помогает рано ловить N+1, неоптимальные джоины и «взрывающуюся» пагинацию.


### Persisting Entities

Идентификаторы важны для производительности вставок. В PostgreSQL почти всегда выбирайте `@GeneratedValue(strategy = SEQUENCE)` + `@SequenceGenerator(allocationSize > 1)`: это позволяет Hibernate брать «пулы» id и эффективно батчить вставки. Стратегия `IDENTITY` часто ломает батчинг, потому что требует немедленной вставки ради получения автоинкрементного ключа. Если цель — производительность на вставке, используйте последовательности и настраивайте батч-размер: `spring.jpa.properties.hibernate.jdbc.batch_size=50` + **SEQUENCE** с `allocationSize=50`.

Каскады (`CascadeType.PERSIST/MERGE/REMOVE/REFRESH/DETACH`) определяют, какие операции переходят по связям. Опасность новичков — ставить `CascadeType.ALL` «везде», что может привести к неожиданным удалением графов сущностей. Выставляйте каскады адресно: где создаёте дочерние вместе с родителем — `PERSIST`, где редактируете — `MERGE`, удаляете — аккуратно и редко.

Жизненный цикл сущностей можно перехватывать через JPA-события (`@PrePersist`, `@PostLoad`, и т. п.). Это удобный инструмент для технических задач (инициализация полей аудита, нормализация), но для бизнес-логики лучше использовать сервисный слой: так логику легче тестировать и сопровождать.

Наконец, реализуйте `equals/hashCode` осознанно. Для сущностей с генерируемым ID обычно применяют «если ID не null — сравниваем по ID, иначе — по ссылке (this==other)». Это предотвращает ловушки с transient-объектами в коллекциях и проблемами из-за прокси Hibernate.


### Defining Query Methods

Имена методов — DSL поверх доменной модели. Операторов много: `Containing`, `StartingWith`, `EndingWith`, `LessThan/Equal`, `Between`, `In`, `True/False`, `IsNull/NotNull`, `Before/After`, `Distinct`, `IgnoreCase`, `OrderBy...Desc`. Комбинируя их, вы быстро описываете повседневные фильтры без единой строчки JPQL.

```java
interface BookRepository extends JpaRepository<Book, Long> {
    Optional<Book> findTopByTitleIgnoreCaseOrderByIdAsc(String title);
    List<Book> findByAuthor_NameAndTitleContaining(String authorName, String titlePart);
    boolean existsByTitle(String title);
    long countByAuthor_Id(Long authorId);
}
```

Пагинация добавляется автоматически, если вы принимаете `Pageable` и возвращаете `Page<T>`/`Slice<T>`. Будьте внимательны с `fetch join` и one-to-many: пагинация поверх `join fetch` порождает дубликаты и неверный `count`. В таких случаях используйте двухшаговый подход (сначала страница `id`, затем `IN`), либо проекцию на агрегированный DTO без коллекций.

Методы `existsBy...` и `countBy...` — оптимальная альтернатива выборкам «на посмотреть». Не грузите целые сущности ради проверки условий. То же верно и для `deleteBy...`/`removeBy...`: это JPQL-модификация, которая работает без загрузки графа, но помните о синхронизации контекста (см. `@Modifying(clearAutomatically = true)`).

Когда имя метода стало нечитаемым или нужно управлять выборкой связей — переходите к явным аннотациям: `@Query`, `@EntityGraph`, или соберите условия через Specification. Это естественная эволюция сложности запросов.


### JPA Query Methods

`@Query` позволяет писать JPQL/SQL явно. JPQL оперирует сущностями и их полями, а не именами колонок. Это делает запросы переносимыми между СУБД и согласованными с моделью. В запросах используйте параметры по имени (`:name`) и избегайте конкатенации строк — так вы защищены от SQL-инъекций на уровне ORM.

```java
@Query("""
   select b
   from Book b
   join fetch b.author a
   where lower(b.title) like lower(concat('%', :q, '%'))
   """)
List<Book> search(@Param("q") String q);
```

Для загрузки связей используйте `join fetch` или `@EntityGraph` — это управляемое решение против N+1. Однако не смешивайте `fetch join` с пагинацией для коллекций — либо стройте отдельный `countQuery`, либо делайте двухшаговую выборку. Для `to-one` `fetch join` безопаснее и часто желателен.

Нативный SQL (`nativeQuery = true`) уместен, когда нужен специфичный синтаксис (оконные функции, CTE, `ON CONFLICT`), тонкая оптимизация или когда выражать бизнес-срез на JPQL сложно. Цена — зависимость от диалекта и ручной маппинг: выбирайте DTO-конструкторы или `SqlResultSetMapping` осознанно.

JPQL поддерживает проекции: `select new com.example.BookDto(b.id, b.title)`. Это отличный способ выдавать «ровно то, что нужно фронту» без перетаскивания графа сущностей в веб-слой. Такой подход уменьшает трафик и предсказуемее по производительности.


### Value Expressions Fundamentals

Spring Data поддерживает SpEL-выражения в `@Query`, в том числе доступ к параметрам метода и бинам контекста: `:#{#param}` или `:#{@beanName.someValue}`. Это удобно для динамической подстановки «глобальных» условий (например, «текущий тенант» или «дата актуальности»), не меняя сигнатуру каждого метода.

С осторожностью используйте SpEL в проекциях через `@Value`. Открытые проекции с вычисляемыми полями выглядят привлекательно, но за ними часто скрывается N+1 (каждое выражение может инициировать доступ к ленивым полям). В большинстве случаев надёжнее явно собрать DTO с нужными полями в `@Query`.

Ещё одна точка применения — динамика сортировок/фильтров. Там, где вам нужно подставить имя колонки/поля, лучше не строить строку JPQL вручную, а передавать `Sort`/`Pageable` в репозиторий. Это безопаснее и понятнее, чем SpEL, и лучше поддерживается средствами фреймворка.

Подводя итог: SpEL — мощный инструмент, но он усложняет тестирование и скрывает зависимости. Применяйте точечно и документируйте места, где логика запроса зависит от внешних бинов/контекста.


### Projections

Проекции позволяют вернуть не всю сущность, а её «срез». Это может быть интерфейс (закрытая/открытая проекция) или класс-DTO через конструктор. Интерфейсные проекции просты, когда поля совпадают по именам, а класс-проекции дают полную типобезопасность и контроль над маппингом.

```java
public interface BookView {
    Long getId();
    String getTitle();
    String getAuthorName(); // из SpEL или через @Value нельзя — лучше DTO
}

@Query("""
   select new com.example.api.BookDto(b.id, b.title, a.name)
   from Book b join b.author a
   where lower(b.title) like lower(concat('%', :q, '%'))
""")
List<BookDto> findDtos(@Param("q") String q);
```

Закрытые интерфейсные проекции маппят поля один-к-одному; открытые допускают `@Value("#{...}")`, но тогда возрастает риск N+1 и «скрытых» вычислений. Если нужно объединять поля разных сущностей, предпочтительнее написать явный JPQL с `select new ... DTO`, где вы точно контролируете джоины и агрегаты.

Проекции — один из ключевых рецептов против N+1 и «тяжёлых» графов. Вместо загрузки `Book -> Author -> Tags` и сериализации всего графа на REST лучше вернуть `BookCardDto` с готовыми строковыми полями `authorName`, `tagNames`, посчитанными на стороне запроса. Это предсказуемо по трафику и читаемо.

Важно помнить, что проекция — это **не** entity. Менять её и ожидать `flush` бессмысленно. Для командных операций держите работу с сущностями в сервисе, а для чтения — отделяйте чтение-модель (DTO/проекции) от записи-модели (сущности).


### Stored Procedures

Хранимые процедуры полезны там, где много данных и логика тесно связана со схемой — агрегации, пересчёты витрин, сложные массовые операции. В Spring Data их можно вызвать через `@Procedure` на методе репозитория, прокинув IN/OUT-параметры как аргументы.

```java
public interface ReportRepository extends Repository<Report, Long> {
    @Procedure("refresh_materialized_views")
    void refreshMviews();
}
```

Преимущество — атомарность и производительность: вся работа выполняется внутри СУБД без лишних сетевых раунд-трипов. Недостаток — логика уезжает в БД, усложняя переносимость, тестирование и ревью. Придерживайтесь разумного баланса: бизнес-правила — на сервисном слое, тяжёлые расчёты — в БД по показаниям.

В PostgreSQL иногда вместо процедур удобнее использовать функции и материализованные представления. Ими тоже можно управлять из приложения (`REFRESH MATERIALIZED VIEW`) — Spring Data это не ограничивает, вы просто исполняете `@Modifying`-запросы.

Не забывайте про транзакционность вызова процедур и про права в БД. На продакшене SQL-учётные записи часто ограничены, а в миграциях могут быть другие роли. Согласуйте это с DBA заранее.


### Specifications

`Specification<T>` — это типобезопасная надстройка над JPA Criteria API. Каждая спека — небольшой предикат: `titleContains(q)`, `authorNameEq(name)`, `publishedBetween(a, b)`. Их можно связывать `where(...).and(...).or(...)`, формируя динамический фильтр на основе входных параметров.

```java
public class BookSpecs {
    public static Specification<Book> titleContains(String q) {
        return (root, cq, cb) -> cb.like(cb.lower(root.get("title")), "%" + q.toLowerCase() + "%");
    }
    public static Specification<Book> authorNameEq(String name) {
        return (root, cq, cb) -> cb.equal(root.join("author").get("name"), name);
    }
}
```

Использование:

```java
repo.findAll(
   where(titleContains(q)).and(authorNameEq(name)),
   PageRequest.of(0, 20)
);
```

Спеки инкапсулируют технические детали (джоины, `lower`, `like`, сравнения), что повышает тестопригодность: вы можете юнит-тестировать каждый предикат отдельно и интеграционные тесты собирать из комбинаций. Это лучше, чем огромные `if-else` в коде и ручная сборка строк JPQL.

Не злоупотребляйте авто-джоинами в спеке: каждый `root.join("...")` добавляет джоин, и при композиции легко получить избыточные запросы. Чётко выделяйте, где спеке нужен `join fetch` (редко) и где достаточно `join` для фильтрации. Помните о пагинации и дубликатах на one-to-many.

Specification хорош, когда форма поиска богата опциями. Если же у вас всего один-два параметра и запрос статичен — `@Query` читабельнее. Всегда выбирайте самый простой инструмент, достаточный для задачи.


### Query by Example

QBE позволяет построить запрос из «примера» (probe) и настроек сопоставления (`ExampleMatcher`). Это быстрая дорожка для простых форм поиска: «строка содержит без учёта регистра», «игнорировать null-поля». Сигнатура методов та же — `findAll(Example.of(...))`.

```java
Book probe = new Book();
probe.setTitle("spring");

ExampleMatcher matcher = ExampleMatcher.matching()
    .withIgnoreCase()
    .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING);

List<Book> books = repo.findAll(Example.of(probe, matcher));
```

Плюс QBE — минимум кода и автоматическое игнорирование пустых полей. Минус — ограниченная выразительность: нет явных `OR` между полями, плохо работает через связи, не выразить сложные условия (`greater/less/between`) без трюков. Это инструмент для простых CRUD-фильтров, а не для аналитических отчётов.

Важный момент — производительность. Под капотом QBE всё равно превращается в критерий-запрос: следите за индексами по колонкам, участвующим в сравнении. `Containing`/`endsWith` плохо индексируются без специальных приёмов (например, `GIN` по `pg_trgm`), но это уже тема проектирования БД.

Если потребность переросла «форма поиска на три поля» — плавно мигрируйте на Specification или явный `@Query`. Это даёт полный контроль над SQL.


### Transactionality

Транзакции — ответственность сервисного слоя. Аннотируйте методы сервисов `@Transactional`, а не контроллеры: так вы держите жизненный цикл транзакции коротким и предсказуемым. Для чтения используйте `@Transactional(readOnly = true)`: Hibernate отключит грязную проверку, а драйвер может выставить «read-only» флаг.

Понимайте ограниченность `readOnly=true`: это не уровень изоляции и не «магический» способ ускорить всё. Он не предотвращает фантомы и не блокирует конкурентные записи. За такими гарантиями — к уровням изоляции (`REPEATABLE_READ`, `SERIALIZABLE`) и блокировкам.

Всегда проектируйте транзакцию вокруг работы с БД. Внешние вызовы (HTTP, Kafka, файловая система) не должны происходить внутри длительных транзакций — это ведёт к долгим блокировкам, таймаутам и взаимоблокировкам. Паттерны «outbox», «transactional events», ретраи и идемпотентность помогают оформить границы правильно.

Не забывайте про Propagation. По умолчанию `REQUIRED` присоединится к текущей транзакции или создаст новую. В редких случаях пригодится `REQUIRES_NEW` (независимый лог/аудит), но используйте его осмотрительно: это уже вложенные транзакции и иная семантика коммитов/роллбеков.


### Locking

Оптимистическая блокировка — по умолчанию фаворит для веб-систем. Добавьте поле `@Version` и Hibernate начнёт проверять версию при обновлении. Конкурентное редактирование одной записи приведёт ко второй попытке с `OptimisticLockException`, которую можно обработать как «страница конфликта» или ретрай.

Пессимистические блокировки (`@Lock(PESSIMISTIC_READ/WRITE)`) запрашивают блок на уровне СУБД. Они нужны там, где недопустима «потеря последнего обновления» и версия не спасает (например, инкременты счётчиков, редкие критичные секции). Помните о таймаутах, эскалации блокировок и возможных дедлоках — обязательно покрывайте такие места интеграционными тестами.

```java
@Entity
class Book {
    @Id Long id;
    @Version Long version;
    // ...
}
```

Выбор стратегии — инженерное решение. Если у вас чтений во много раз больше, чем записей, оптимистический путь дешевле: нет блокировок, а конфликт — редкая ситуация. Если же критичны строгие инварианты и записи конфликтуют часто — проектируйте под пессимистический сценарий и продумывайте ретраи.

Блокировки действуют только в транзакциях. Не имеет смысла вызывать методы с `@Lock` вне `@Transactional`: СУБД просто не закрепит блок. Это типичная ловушка новичков при первых попытках «починить» гонки.


### Auditing

Spring Data JPA умеет автоматически заполнять поля «кто и когда создал/изменил». Для этого включите `@EnableJpaAuditing`, добавьте `AuditorAware<?>` (например, берущий имя пользователя из `SecurityContext`), а в сущностях отметьте поля `@CreatedDate`, `@LastModifiedDate`, `@CreatedBy`, `@LastModifiedBy`.

```java
@Entity
@EntityListeners(AuditingEntityListener.class)
class Book {
    @CreatedDate Instant createdAt;
    @LastModifiedDate Instant updatedAt;
    @CreatedBy String createdBy;
    @LastModifiedBy String modifiedBy;
}
```

Аудит полезен не только для расследований. Он позволяет строить бизнес-правила («редактирование запрещено, если запись не ваша», «показывать историю изменений») и облегчает сопровождение в команде (видно, кто вносил правки). В связке с версионированием по `@Version` видна и «линейка» изменений.

Следите за типами полей: для времени предпочтительнее `Instant/OffsetDateTime` (UTC), а не локальные `LocalDateTime`. Это снимает вопросы с часовыми поясами, особенно если у вас несколько датацентров или микросервисы в разных зонах.

Также определите политику заполняемости. Нельзя полагаться только на приложение: при необходимости дублируйте значения через триггеры в БД, чтобы защититься от «ручных» вмешательств или сбоев в приложении при миграциях.


### Merging persistence units

В большинстве Spring Boot-проектов у вас один persistence unit, прозрачно собранный автоконфигурацией. Однако в монорепозиториях или крупных системах встречается несколько модулей/банок с разными наборами сущностей. Тогда важно корректно «сливать» их в единый `EntityManagerFactory` или осознанно держать раздельно.

Если сущности разбросаны по разным пакетам/модулям, убедитесь, что сканирование охватывает их все: либо размещайте `@SpringBootApplication` в родительском пакете, либо указывайте `@EntityScan`/`packagesToScan`. Ошибка «Unknown entity» чаще всего из-за того, что класс не попал в скан.

Иногда нужно действительно несколько persistence units (разные БД/транзакционные границы). Тогда настраивают несколько `EntityManagerFactory` и `PlatformTransactionManager`, помечая репозитории `@EnableJpaRepositories(entityManagerFactoryRef = "...", transactionManagerRef = "...")`. Это более сложная конфигурация и требует дисциплины в зависимостях.

Документируйте границы: какие пакеты относятся к какому юниту, что можно ссылать, а что — нет. Это избавляет от «скрытых» зависимостей и неожиданных кросс-линков в сущностях.


### Custom Repository Implementations

Когда derived-методов и `@Query` недостаточно, добавьте кастомный фрагмент. Вы объявляете интерфейс `XxxRepositoryCustom` с необходимыми методами и класс `XxxRepositoryImpl`, где внедряете `EntityManager` и пишете JPQL/Criteria/SQL на свой вкус. Затем основной репозиторий расширяет оба интерфейса.

```java
public interface BookRepositoryCustom {
    List<BookDto> findPopularBooks(int minSales);
}

public class BookRepositoryImpl implements BookRepositoryCustom {
    @PersistenceContext private EntityManager em;
    @Override
    public List<BookDto> findPopularBooks(int minSales) {
        return em.createQuery("""
           select new com.example.api.BookDto(b.id, b.title, a.name)
           from Book b join b.author a
           where b.sales >= :min
           order by b.sales desc
        """, BookDto.class).setParameter("min", minSales).getResultList();
    }
}

public interface BookRepository extends JpaRepository<Book, Long>, BookRepositoryCustom {}
```

Это даёт контроль над запросами и планами выполнения, возможность применять хинты (`@QueryHints`), временные таблицы, специфичный SQL. Вы можете собирать сложные DTO, запускать batch-операции, настраивать таймауты. Такой слой легко тестировать интеграционно, изолируя его от остального приложения.

Транзакции для кастомных методов обычно оформляют на сервисном слое. Если метод чисто чтение, можно обойтись без явной аннотации — он «унаследует» транзакцию сервиса. Для модификаций не забывайте о `flush`/очистке контекста, особенно если используете bulk-операции (`update/delete`), обходящие managed-сущности.

Держите реализацию фрагмента компактной и предметной. Если метод превращается в маленький ORM-фреймворк, возможно, время вынести его в отдельный «порт» слоя доступа к данным с явным контрактом и тестами.


### Null Handling of Repository Methods

Для одиночных выборок выбирайте `Optional<T>`. Это явный контракт: сущности может не быть. Избегайте возвращать `null` — это источник `NullPointerException` и лишних проверок на клиентах. Там, где 404 — нормальный сценарий, оборачивайте `Optional` в исключение с понятным сообщением на веб-слое.

Коллекции всегда возвращайте пустыми, а не `null`. Это делает код клиента проще: можно сразу итерироваться или проверять `.isEmpty()`. Для подсчётов используйте `long`/примитивы вместо `Long` — нулевое значение естественно и не требует распаковки.

Методы, которые «создают или обновляют», должны чётко документировать семантику. `save` в Spring Data может вести себя как `persist` или `merge` в зависимости от состояния сущности/ID. Если бизнес-требование — «ошибаться, если сущность уже есть/нет», пишите явную проверку перед `save`.

Если нужен «мягкий» поиск с дефолтами, инкапсулируйте это в сервисе: `repo.findById(id).orElseThrow(...)` или `orElseGet(() -> createDefault(...))`. Контракт репозитория должен оставаться простым и предсказуемым.


### Spring Data Extensions

`@EntityGraph` управляет подзагрузкой связей без `fetch join` в тексте запроса. Это удобно, когда один и тот же метод то возвращает «лёгкий» срез, то «толстый» с подгруженным автором/ролями. Графы можно именовать и переиспользовать, что повышает выразительность.

```java
@EntityGraph(attributePaths = {"author"}) List<Book> findAll();
```

`@Modifying` включает bulk-операции JPQL (`update/delete`). Они быстры, так как работают на уровне БД и не тащат сущности в контекст. Помните, что контекст после bulk-операции рассинхронизирован — используйте `clearAutomatically = true` или вручную чистите/перечитывайте нужные объекты.

```java
@Modifying 
@Query("delete from Book b where b.sales = 0")
```

События JPA (`@PrePersist`, `@PostUpdate` и т. д.) и события Spring Data (например, `AbstractAuditable`) дают точки расширения. Применяйте их для технических задач (аудит, нормализация), но избегайте бизнес-правил — они хуже тестируются и «прячутся» от читателя кода.

Есть и мелкие, но полезные расширения: `@QueryHints` для подсказок планировщику, `@Fetch`/`@BatchSize` (Hibernate-аннотации) для настройки ленивой загрузки, стримовые результаты, Slice для «бесконечных списков». Эти элементы точечно улучшают UX и производительность.


### Repository query keywords

Ключевые слова в именах методов — мини-язык запросов. `Containing/StartingWith/EndingWith` соответствуют `LIKE` и хорошо читаются. `LessThan/GreaterThan/Between` покрывают сравнения чисел и дат. `IsNull/IsNotNull`, `True/False` удобны для флагов, `In/NotIn` — для множественных фильтров.

`Distinct` помогает убрать дубликаты при джоинах, но помните, что это фильтрация на уровне результата, а не лечение неправильной модели запроса. `IgnoreCase` — сахар для приведения к одному регистру; под капотом это обычно `lower(column)`, требующее осмысленных индексов для производительности.

Сложные имена вроде `findTop10ByStatusAndCreatedAtBetweenOrderByPriorityDescIdDesc` работают, но ухудшают читаемость. В таких случаях лучше перейти на `@Query` c читаемым JPQL или Specification, а в имени оставить суть («search», «findPageByFilter»). Документация метода важнее «всемогущего» имени.

Наконец, помните, что ключевые слова — часть API. Их изменения — это breaking-change для клиентов вашего модуля. Стабилизируйте контракт, пишите JavaDoc и придерживайтесь единых соглашений в команде.


### Repository query return types

`Page<T>` — когда нужен **размер страницы, общее количество и номер страницы**. Это дороже: фреймворк выполнит отдельный `count`. `Slice<T>` — когда достаточно знать «есть ли следующая страница» без общего количества; он дешевле и подходит для лент/скроллов.

`List<T>` — самый простой возврат без пагинации. Не используйте его для «бесконечных списков» — ограничивайте размер через `Pageable` или `TopN`, иначе легко получить перегрузку БД и сети. `Stream<T>` — аккуратный инструмент для обработки больших выборок, но держите транзакцию открытой и закрывайте стрим.

Для агрегатов возвращайте скаляры/DTO: `long count`, `BigDecimal sum`, `new Dto(a, b)`. Не тащите целые сущности, если нужны только числа. Это экономит трафик и упрощает код клиента.

Асинхронные возвращаемые типы (например, `CompletableFuture<List<T>>`) уместны в Spring Data для реактивных модулей (R2DBC), но в JPA-модуле они не играют, так как JPA блокирующая. Для конкурентных сценариев лучше распараллеливать на уровне сервисов/исполнителей.


### Frequently Asked Questions

**Чем `EntityManager` отличается от `JdbcTemplate`?** Первый — ORM-контракт (сущности, контекст, dirty checking), второй — удобная обёртка над «чистым» JDBC. Они часто сосуществуют: сущности для CRUD, `JdbcTemplate` — для отчётных/массовых SQL.

**Почему `save` делает `UPDATE`, хотя поле не менялось?** Возможно, вы модифицируете коллекцию/связь, которую Hibernate воспринимает как изменённую, или у вас неверный `equals/hashCode`, и контейнер коллекции «думает», что элемент поменялся. Смотрите SQL и настраивайте `@EqualsAndHashCode` корректно.

**Как лечить N+1?** Используйте `join fetch`/`@EntityGraph` для нужных связей, `default_batch_fetch_size` для ленивых коллекций и DTO-проекции вместо загрузки всего графа. Следите за пагинацией — не смешивайте `fetch join` и страницы по коллекциям.

**Почему пагинация даёт дубликаты?** Вы сделали `join` на коллекцию. Либо перепишите запрос на двухшаговый (сначала id, потом `IN`), либо считайте агрегаты/DTO без коллекции, либо переносите коллекцию в отдельный запрос по надобности.


### Категории частых ошибок

Первая категория — про загрузку данных. Использование EAGER «по умолчанию», особенно на `@ManyToOne`, приводит к «тяжёлым» графам и непредсказуемым запросам. Всегда ставьте `fetch = LAZY` и управляйте подзагрузкой явно через `fetch join`/`@EntityGraph`. Вторая — N+1: вызов ленивой связи в цикле порождает лавину запросов; лечится перечисленными инструментами и проекциями.

Вторая категория — про вставки/обновления. На PostgreSQL стратегия `IDENTITY` ломает батч-вставки; используйте `SEQUENCE` + `allocationSize`. Бездумные `CascadeType.ALL` приводят к случайным удалениям — задавайте каскады ровно там, где они нужны. Bulk-операции `@Modifying` десинхронизируют контекст — чистите его после апдейтов.

Третья категория — про транзакции. Долгие транзакции вокруг внешних вызовов (HTTP, MQ, файловая система) завершаются блокировками и таймаутами. Держите транзакции короткими и только вокруг работы с БД. `@Transactional(readOnly = true)` не волшебная палочка: он не меняет уровень изоляции и не предотвращает гонки.

Четвёртая — про модель и равенство. Неверный `equals/hashCode` на сущностях ломает коллекции и вызывает лишние апдейты. Ставьте `@Version` там, где возможны конкурентные правки, и продумывайте стратегию конфликтов (ретраи, страница конфликта, пессимизм). Сериализовать сущности напрямую в REST — путь к циклическим зависимостям и утечке доменных деталей: всегда возвращайте DTO.

### Типичные ошибки новичков 

1. **EAGER по умолчанию** на `@ManyToOne` — ведёт к тяжёлым графам загрузки. Ставьте `fetch = LAZY`.
2. **N+1** при обходе коллекций — лечится `join fetch` / `EntityGraph` / batch-fetch / проекциями.
3. **`IDENTITY` в PostgreSQL** и жалобы на скорость массовых вставок — переходите на `SEQUENCE` + batching.
4. **Путаница во владельце связи** — лишние join-таблицы/апдейты. Держите FK у владельца, `mappedBy` — на обратной стороне.
5. **Пагинация с `fetch join` на `@OneToMany`** — дубли и неверный count. Делайте двухшаг или DTO.
6. **Ожидание «магического» коммита без транзакции** — помните про `@Transactional` на сервисе.
7. **Мутация сущностей в `readOnly`-транзакции** — изменения не применятся (и это хорошо); не полагайтесь на «вдруг сохранится».
8. **`equals/hashCode` по всем полям** — прокси ломают равенство, коллекции «заедают». Следуйте паттерну «ID или ссылочное».
9. **Бездумное `cascade = CascadeType.ALL`** — можете удалить «пол-базы». Определяйте каскады адресно.
10. **`@Transactional` на контроллерах** — увеличивает время жизни транзакций, риски блокировок. Держите транзакции на сервисном слое и короткими.
11. **Хранение больших коллекций прямо в сущности** и попытка грузить их «целиком» — делайте срезы/проекции/пагинацию.
12. **Игнор логов SQL** — не видно, что реально исполняется. Включайте `show-sql`/логгер JDBC и смотрите планы в БД.
13. **Невнятные индексы под запросы** — проверяйте, что колонки из `where/join/order by` покрыты индексами (особенно для внешних ключей).
14. **Сквозная сериализация сущностей в JSON** — циклические ссылки, лишние поля, N+1 на веб-слое. Возвращайте DTO.
15. **Оптимистическое «молча»** — забытый `@Version` в конкурентных сценариях приводит к потерям обновлений.



### Итог

Spring Data JPA — зрелый инструмент, снимающий рутину и дисциплинирующий работу с БД. Освоив фундамент (контекст постоянства, состояния сущностей, моменты `flush`), вы получаете удобные репозитории, читаемые имена методов, проекции, спецификации, аудит и грамотную транзакционность. Это позволяет быстро строить надёжные и производительные сервисы на понятном стеке.

Золотое правило — начинать с простого и эволюционировать: derived-методы и `Pageable` → явный `@Query` и DTO → Specification/QBE для динамики → кастомный фрагмент там, где нужен точный контроль. Всегда смотрите на SQL, проверяйте планы выполнения и держите миграции в порядке — и JPA/ Hibernate будут на вашей стороне.

Наконец, не забывайте про доменную модель. Хорошо спроектированные сущности, осмысленные связи и индексирование по фактическим запросам дают львиную долю производительности. Spring Data JPA лишь усиливает правильный дизайн — и не спасает от неправильного.

**Теоретические материалы**
---------------------------

-   Spring Docs: [Spring Data JPA Reference](https://docs.spring.io/spring-data/jpa/reference/) (англ.) 
-   Spring Docs: [Spring Data --- Repositories](https://docs.spring.io/spring-data/commons/reference/repositories/introduction.html) (англ.)
-   Spring Docs: [Spring Framework --- Transactions](https://docs.spring.io/spring-framework/reference/data-access/transaction.html) (англ.)
-   JakartaEE: [Jakarta Persistence (JPA) Specification](https://jakarta.ee/specifications/persistence/) (англ.)
-   Hibernate: [Hibernate ORM User Guide](https://hibernate.org/orm/documentation/) (англ.)
-   Vladmihalcea: [High-Performance Java Persistence --- Best Practices](https://vladmihalcea.com/tutorials/hibernate/) (англ.)
-   Baeldung: [Spring Data JPA --- Repositories](https://www.baeldung.com/spring-data-jpa-repositories) (англ.)
-   Baeldung: [JPA and Hibernate --- Entity Relationships](https://www.baeldung.com/hibernate-one-to-many) (англ.)
-   Baeldung: [JPQL and Native Queries](https://www.baeldung.com/jpa-queries) (англ.)
-   Baeldung: [Pagination and Sorting with Spring Data JPA](https://www.baeldung.com/spring-data-jpa-pagination-sorting) (англ.)
-   Baeldung: [JPA Entity Graph](https://www.baeldung.com/jpa-entity-graph) (англ.)
-   Baeldung: [Projections in Spring Data JPA](https://www.baeldung.com/spring-data-jpa-projections) (англ.)
-   Хабр: [Spring Data JPA](https://habr.com/ru/articles/435114/) (рус.)
-   Хабр: [Spring Data JPA: что такое хорошо, и что такое плохо](https://habr.com/ru/articles/441386/)
-   Хабр: [Построение динамических запросов к базе данных с использованием Spring Data JPA Specifications](https://habr.com/ru/articles/870698/) (рус.)
-   Хабр: [Hibernate Best Practices для начинающих](https://habr.com/ru/articles/679216/) (рус.)
-   Хабр: [Hibernate, JPA, N+1 и лишние запросы в БД](https://habr.com/ru/articles/896618/) (рус.)
-   Хабр: [Проблема с N+1 запросами в JPA и Hibernate](https://habr.com/ru/companies/otus/articles/529692/) (рус.)

**Вопросы с ответами**
---
1.  **Что даёт использование JPA по сравнению с «ручным» JDBC?**\
    Декларативное описание модели и связей, автоматическое сопоставление объектов и строк таблиц, кеширование контекста, dirty checking, переносимость между СУБД. Вы пишете бизнес-код, а не сборку SQL и разбор `ResultSet`.

2.  **Какую роль играет `EntityManager` и чем он отличается от `JdbcTemplate`?**\
    `EntityManager` управляет контекстом персистентности: делает `persist/merge/remove/find`, трекает изменения и синхронизирует с БД. `JdbcTemplate` --- тонкая обёртка над JDBC без ORM; вся маппинг-логика на вас.

3.  **Чем `transient`, `managed`, `detached`, `removed` состояния сущности отличаются?**\
    `transient` --- объект вне контекста; `managed` --- под наблюдением, изменения попадут в БД при `flush`; `detached` --- потерял связь (нужно `merge` или заново загрузить); `removed` --- помечен на удаление до `flush/commit`.

4.  **Что такое dirty checking и когда происходит `flush`?**\
    Сравнение снимка управляемой сущности с её текущим состоянием; при различиях генерируется SQL. `flush` срабатывает при коммите транзакции, вручную (`em.flush()`), и иногда перед JPQL-запросами, если провайдер считает, что нужно согласовать состояние.

5.  **Как выбор стратегии `@GeneratedValue` влияет на производительность вставок?**\
    `IDENTITY` требует немедленного `INSERT` для получения ключа --- мешает батчингу; `SEQUENCE` позволяет заранее получать пачки ID и эффективно вставлять массово; `TABLE` редко используют; `AUTO` делегирует выбор провайдеру.

6.  **Кто «владелец» связи в `@OneToMany/@ManyToOne` и почему это важно?**\
    Владелец --- сторона с FK/`@JoinColumn` (обычно `@ManyToOne`). Только изменения на владельце отражаются в БД. Если ошибочно сделать владельцем не ту сторону, обновления FK не будут применяться.

7.  **Зачем `mappedBy` и `@JoinColumn`, и что произойдёт при неверной стороне владения?**\
    `mappedBy` указывает, что колонкой управляет другая сторона. `@JoinColumn` задаёт FK. При неверной стороне --- лишние таблицы/связки, дублирующие записи и «потерянные» апдейты.

8.  **Почему `LAZY` загрузка предпочтительнее `EAGER` и когда `EAGER` допустим?**\
    `LAZY` избегает лишнего SQL и позволяет контролировать граф данных. `EAGER` приемлем для маленьких неизменяемых справочников или когда вы всегда используете поле.

9.  **Что такое N+1 запросов и как его устранить?**\
    1 запрос на коллекцию родителя + N запросов по элементам. Исправляют fetch join, EntityGraph, явной загрузкой нужных связей и переразметкой запросов на агрегаты.

10. **Чем JPQL отличается от нативного SQL и от Criteria API?**\
    JPQL --- объектно-ориентированный «SQL по сущностям», портируемый между СУБД. Нативный SQL --- по таблицам/колонкам, нужен для сложных/специфичных запросов. Criteria --- типобезопасный построитель JPQL в коде.

11. **Что такое `JpaRepository` и какие плюсы derived queries по имени метода?**\
    Базовый интерфейс репозитория с CRUD, пагинацией и «именованными» запросами по схеме `findByXAndY`. Плюс --- скорость разработки и согласованность именования.

12. **Как работает пагинация и сортировка через `Pageable`/`Sort`?**\
    `findAll(Pageable)` возвращает `Page<T>` с контентом, номером страницы, размером, общим количеством. `Sort` добавляет порядок. Используется в репозиторных методах.

13. **Когда использовать `@Query` и проекции (интерфейс/DTO) вместо сущностей?**\
    Когда нужен срез данных/агрегаты/джоины, которые не укладываются в «деривативы» по имени. Проекции уменьшают граф загрузки и объём ответа.

14. **Что делает `@Transactional(readOnly = true)` и на что это не влияет?**\
    Включает транзакцию только-чтение: отключает грязные проверки Hibernate, сообщает драйверу о режиме. Не меняет сами SQL и индексы; это не оптимизатор запросов.

15. **Чем опасен `equals/hashCode` на сущностях и как его писать?**\
    Ошибки ведут к «пропаже» элементов из коллекций/кэшев. Безопасно: основание на неизменяемом бизнес-ключе **или** на `id` после присвоения (и аккуратно до присвоения).

16. **Когда применимы `@Embeddable`/`@Embedded` и чем они отличаются от отдельной сущности?**\
    Для композиции «значений»: нет собственного идентификатора и жизненного цикла, поля встраиваются в таблицу владельца. Отдельная сущность живёт сама по себе и может иметь связи.

17. **Как выбрать стратегию наследования (`SINGLE_TABLE`, `JOINED`, `TABLE_PER_CLASS`)?**\
    Если нужна скорость и немного полей-«дырок» --- `SINGLE_TABLE`. Нормализованные модели и отчёты --- `JOINED`. `TABLE_PER_CLASS` --- редко, когда нет общих запросов по базе.

18. **Что такое EntityGraph и как он помогает с ленивыми полями?**\
    Граф указывает, какие ассоциации загрузить вместе с сущностью. Применяется к методу репозитория/запросу и избегает N+1 без `fetch join` в JPQL.

19. **Как написать частичный апдейт: «изменить только имя» без загрузки всего объекта?**\
    Либо `@Modifying @Query("update User u set [u.name](http://u.name/)=?2 where [u.id](http://u.id/)=?1")`, либо загрузить управляемую сущность и изменить одно поле --- Hibernate сгенерирует `update` только для изменённых колонок (при настроенном dirty checking).

20. **Где правильнее ставить границы транзакций и почему не в контроллере?**\
    В сервисном слое: транзакция охватывает бизнес-операцию, а не HTTP. Это упрощает повторное использование, тестирование и предотвращает «слияние» транспортной и доменной логики.

21. **Как совместить fetch join и пагинацию, не нарушая семантику `Page`?**\
    Для коллекций --- нельзя корректно: fetch join × коллекции ломает подсчёт и дублирует строки. Решение: пагинация по корневой сущности (без fetch join), затем отдельные запросы для связей или использовать `@EntityGraph`/батч-загрузку.

22. **Какую проблему создаёт стратегия `IDENTITY` для batching и как её обойти?**\
    Невозможность предвыделить ключи --- каждый insert должен выполниться сразу. Обход: перейти на `SEQUENCE` с оптимизаторами и включить JDBC batching.

23. **Когда уместно использовать Specification/Criteria, а когда лучше собрать SQL руками?**\
    Когда фильтры динамические и должны составляться на лету --- Specification/Criteria хороши. Если нужен сложный, тюнингованный под СУБД запрос/CTE/хинты --- пишите нативный SQL.

24. **Как безопасно удалять элементы коллекции «владельца» с `orphanRemoval` и без каскада REMOVE?**\
    Делайте изменения **на стороне владельца** (например, `parent.getChildren().remove(child)`), при `orphanRemoval=true` сирота удалится. Без него --- явно удаляйте через репозиторий.

25. **Как контролировать размер графа загрузки при отдаче из REST, чтобы не получить лавину SQL?**\
    Возвращайте DTO/проекции, используйте целевые запросы/графы, не отдавайте ленивые коллекции «наружу», проверяйте SQL и размер ответа. Пагинация обязательна.

**Практические задачи**
-----------------------

1.  **Базовый CRUD c Spring Data JPA и H2**\
    Описание: создайте `User` (`id, email, displayName, createdAt`) и `UserRepository extends JpaRepository<User, Long>`. Реализуйте `POST /users`, `GET /users/{id}`, `GET /users` (пагинация), `DELETE /users/{id}`.

    Примеры входных и выходных данных:
    -   `POST {"email":"a@[ex.com](http://ex.com/)","displayName":"A"}` → `201 Created`, тело с `id`.
    -   `GET /users?page=0&size=2` → `200`, `{"content":[...],"totalElements":...}`.

2.  **Derived queries по имени метода**\
    Описание: в `UserRepository` добавьте `findByEmail`, `findByDisplayNameContainingIgnoreCase`. Проверьте поведение при отсутствующем результате.

    Примеры:
    -   `GET /users/search?email=a@[ex.com](http://ex.com/)` → пользователь найден.
    -   `GET /users/search?q=mi` → список имён, содержащих `mi`.

3.  **Связь `@OneToMany`/`@ManyToOne`**\
    Описание: добавьте `Post(id, user, title)`, связь `ManyToOne(User)`, на `User` --- `OneToMany(posts)` c `mappedBy`. Реализуйте создание поста конкретного пользователя.

    Примеры:
    -   `POST /users/1/posts {"title":"Hello"}` → пост привязан к `user=1`.

4.  **N+1 и fetch join**\
    Описание: эндпойнт `GET /users-with-posts`: сначала реализуйте наивно (N+1), затем перепишите репозиторный запрос с `join fetch`. Сравните число SQL в логах.

    Примеры:
    -   До: `1 + N` запросов.
    -   После: 1 запрос.

5.  **Пагинация + сортировка**\
    Описание: `GET /posts?size=5&page=0&sort=createdAt,desc`.

    Примеры:
    -   Разные страницы и порядки сортировки.

6.  **Проекции: интерфейс и DTO**\
    Описание: сделайте интерфейсную проекцию `UserView { String getEmail(); String getDisplayName(); }` и DTO-проекцию через `@Query("select new ...UserDto([u.id](http://u.id/),u.email) from User u")`.

    Примеры:
    -   `GET /users/view` → массив `UserView`.
    -   `GET /users/dto` → массив DTO.

7.  **`@Transactional` в сервисе**\
    Описание: метод `registerUser` создаёт пользователя и сразу добавляет приветственный пост (два репозитория). Оберните в транзакцию.

    Примеры:
    -   Успех → оба объекта в БД.
    -   Искусственная ошибка после первого шага → откат.

8.  **Частичный апдейт именем**\
    Описание: `PATCH /users/{id}` меняет только `displayName`. Реализуйте через `@Modifying @Query` или «загрузка + изменение поля».

    Примеры:
    -   `PATCH {"displayName":"New"}` → `204`.
    -   Неверный id → `404`.

9.  **Embeddable: Address**\
    Описание: добавьте `@Embeddable Address { city, zip }` и поле `@Embedded` в `User`. Реализуйте изменение адреса.

    Примеры:
    -   `PUT /users/1/address {"city":"SPB","zip":"190000"}` → `204`.

10. **EntityGraph против fetch join**\
    Описание: добавьте метод `findAll()` с `@EntityGraph(attributePaths = "posts")` и сравните поведение с запросом `join fetch`.

    Примеры:
    -   Оба способа возвращают пользователей с постами; проверьте число SQL.

11. **Стратегия генерации ID и batching**\
    Описание: создайте много `Post` (например, 10k). Сравните время вставки и число SQL при `IDENTITY` и `SEQUENCE` (с включённым JDBC batching).

    Примеры:
    -   График/замер: `SEQUENCE` быстрее и меньше запросов.

12. **Удаление «сирот» корректной стороной**\
    Описание: у `User` коллекция `posts` с `orphanRemoval=true`. Удалите элемент через `user.getPosts().remove(post)` и проверьте, что запись в БД удалена без ручного `delete`.

    Примеры:
    -   До/после удаления: проверка в БД.

13. **Пагинация при сложных связях**\
    Описание: выведите страницу пользователей, а затем догрузите их последние 3 поста одним дополнительным запросом (или батч-загрузкой), не нарушая `Page` метаданные.

    Примеры:
    -   `GET /users?page=0&size=10` → пользователи + посты, без дубликатов и «кривой» пагинации.